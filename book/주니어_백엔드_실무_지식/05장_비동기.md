## 5. 동기 연동과 비동기 연동

로그인에 성공하면 포인트를 지급하는 기능이 있고, 유저 조회, 포인트 지급, 로그인 내역 추가가 동기 방식으로 실행된다고 생각해보자. **포인트 지급은 연동 서비스이기에 느려질수록 로그인 응답 시간도 길어진다.** 로그인 시 포인트 지급 결과가 필요한 게 아니라면 비동기 방식으로 연동하는 것을 고려할 수 있다.

아래 특징을 통해 비동기로 처리할 수 있는지 검토할 수 있다.

1. 연동에 약간의 시차가 생겨도 문제가 되지 않는다.
    - 쇼핑몰에서 주문이 완료된 후 1분 뒤에 판매자에게 푸시가 나가도 지장이 없다.
2. 일부 기능은 실패했을 때 재시도가 가능하다.
    - 학습 완료 후 포인트 지급 실패 시 재시도, 인증 번호 SMS 다시 받기
3. 연동에 실패했을 때 나중에 수동으로 처리할 수 있다.
    - 검색 서비스 연동 실패 시, 관리자가 수동으로 컨텐츠를 검색 서비스에 연동
4. 연동이 실패했을 때 무시해도 되는 기능이 있다.
    - 주문이 들어왔을 때 판매자에게 푸시가 발송되지 않더라도 판매에는 문제가 생기지 않는다.

비동기 연동 방식

1. 별도 스레드로 실행하기
2. 메시징 시스템 이용하기
3. 트랜잭션 아웃박스 패턴 사용하기
4. 배치로 연동하기
5. CDC 이용하기

### 5-1. 별도 스레드로 실행하기

```java
// 스레드 풀 활용
ExecutorService executor = Executors.newFixedThreadPool(50)
...
public OrderResult placeOrder(OrderRequest req) {
		// 주문 생성 처리
		...
		// 스레드 풀을 이용해서 푸시를 비동기로 발송
		executor.submit(() -> pushClient.sendPush(pushData));
		
		return successResult(...); // 푸시 발송을 기다리지 않고 리턴
}
```

```java
// 스프링이 제공하는 @Async 활용
@Async
public void sendPushAsync(PushData pushData) {
		pushClient.sendPush(pushData);
		// ... 기타 코드
}
```

- 비동기로 실행되는 메서드 이름에 관련된 단어 추가하기
- 비동기로 실행되면 예외가 발생해도 catch 블록은 실행되지 않는다. 내부에서 직접 처리해야 한다.

### 5-2. 메시징

서로 다른 시스템 간에 비동기로 연동하여 메시지를 보낼 때 메시징 시스템을 사용한다.

1. 시스템 A가 전달할 데이터를 메시지로 생성하여 메시징 시스템에 전달한다.
2. 메시징 시스템은 전달받은 메시지를 시스템 B에 전달하고, 시스템 B는 데이터로 필요한 작업을 처리한다.

메시징 시스템을 사용하면 구조가 더 복잡해지지만 어떤 이점이 있을까 ?

- 서로 다른 시스템에 영향을 주지 않는다. (시스템들은 직접 연동하지 않기에 성능 저하 전파가 없다.)
- 확장이 용이하다. (새로운 시스템이 추가된다면 메시징 시스템에 연결하면 된다.)

메시지 생성 측에선 메시지가 유실되는 것을 고려해야 한다. 오류 처리를 위해 다음을 생각할 수 있다.

1. 오류를 무시한다. → 치명적인 오류가 아니라면 가능 (메시지 유실)
2. 재시도한다. → 일시적인 네트워크 오류로 중복 전송이 아니라면 가능
3. 실패 로그를 남긴다. → 후처리에 필요한 데이터를 담고 있어야 함

메시지 소비 측에선 중복 메시지 처리와 모니터링을 고려해야 한다.

- 동일 데이터를 가진 중복 메시지는 고유 ID를 통해 무시할 수 있다.
- 메시지 재수신에 따른 중복 처리에 대응하는 방법은 멱등성을 가진 API를 구현해야 한다.
    - 외부 API를 호출했을 때 발생한 읽기 타임아웃이 발생했는데 성공했다면 중복 호출하게 된다.
- 소비자가 메시지를 잘 소비하고 있는지 모니터링 한다.
    - 소비자의 메시지 처리속도가 느려지면 메시징 시스템의 큐가 가득 차게 되고, 생산자의 성능 저하를 유발한다.

메시지의 종류

1. 이벤트 → 상태가 변경되거나 어떤 활동이 일어나는 경우 (배송을 완료함, 로그인에 실패함)
2. 커맨드 → 무언가를 요청하는 메시지 (포인트 지급하기, 배송 완료 문자 발송하기)

### 5-3. 트랜잭션 아웃박스 패턴

DB 트랜잭션에 실패했는데 메시지를 전송하면 잘못된 데이터를 보낼 수 있기 때문에 트랜잭션이 끝난 뒤에 메시지를 보내야 한다. 하지만 이렇게 해도 메시징 시스템에 연동이 실패할 수 있어서 완벽하지 않다. 메시지가 유실되지 않도록 보장하는 방법은 **트랜잭션 아웃박스 패턴**을 활용하는 것이다.

1. 실제 업무 로직에 필요한 DB 변경 작업을 수행한다.
2. 메시지 데이터를 아웃박스 테이블에 추가한다.
3. 저장된 메시지를 읽어 메시징 시스템에 전송한다. (전송에 성공하면 완료 처리)

트랜잭션 아웃박스 패턴의 특징

- 트랜잭션을 롤백하면 메시지 데이터도 함께 롤백되므로 잘못된 메시지 데이터가 전송될 일도 없다.
- 메시지 리스트를 전송하면서 중간에 실패하면, 루프를 멈춘다. 이유는 메시지를 생성 순서대로 보내기 위함이다.
- 발송 완료를 표시하는 방법은 2가지가 있다.
    1. 아웃박스 테이블에 발송 상태 칼럼을 둔다. (발송 대기, 발송 완료, 발송 실패)
    2. 메시지 중계 서비스가 성공한 마지막 메시지 ID 별도로 기록한다.
        - 다음번 대기 메시지를 조회할 때 이 ID 이후의 메시지만 선택한다.
        - 2개 이상의 메시지 중계 서비스 환경이라면 각 서비스가 고유하게 마지막 메시지 ID를 관리해야 한다.

**아웃박스 테이블 구조**

| id | big int | 단순 증가 값 (PK) |
| --- | --- | --- |
| messageId | varchar | 메시지 고유 ID (고유키) |
| messageType | varchar | 메시지 타입 |
| payload | clob | 메시지 데이터 |
| status | varchar | 이벤트 처리 상태 (대기, 완료, 실패) |
| failCount | int | 실패 횟수 |
| occuredAt | timestamp | 메시지 발생 시간 |
| processedAt | timestamp | 메시지 처리 시간 |
| failedAt | timestamp | 마지막 실패 시간 |

### 5-4. 배치 전송

메시징 시스템은 실시간으로 데이터를 연동한다면, 배치는 일정 간격으로 데이터를 전송한다. 예를 들어 결제 승인 데이터를 모아서 다음 날 보내거나, 택배 발송 요청 데이터를 1시간 간격으로 보낸다.

1. DB에서 전송할 데이터를 조회한다.
2. 조회한 결과를 파일로 기록한다.
3. 파일을 연동 시스템에 전송한다.
- 파일 전송은 FTP, SFTP 같은 프로토콜, SCP와 같은 명령어를 이용해 수행한다.
- 주로 사용하는 파일 형식은 값1(구분자)값2 / 이름1=값1 이름2=값2 / JSON 문자열이 존재한다.
- 데이터를 전송할 때 파일 전송, HTTP API, DB 접근 방법을 활용할 수 있다.
- 파일을 지정된 시간에 전송하지 못할 때가 있으므로, 재시도 로직과 수동 배치 실행, API를 만들어두자.

### 5-5. CDC (Change Data Capture)

CDC는 변경된 데이터를 추적하고 판별해서 변경된 데이터로 작업을 수행할 수 있도록 하는 소프트웨어 설계 패턴이다. 오라클이나 MySQL 같은 DBMS는 데이터가 변경되면 그 변경 내용을 통지하는 기능을 제공한다. CDC는 이 기능을 활용해서 구현한다.

크게 2가지 형태로 대상 시스템에 변경된 데이터를 전파한다.

1. 변경 데이터를 그대로 대상 시스템에 전파
    - 회원 시스템의 회원 데이터가 변경됐을 때, 컨텐츠 시스템의 회원 테이블 동기화하는 1대1 관계일 때 적합하다.
2. 변경 데이터를 가공해서 대상 시스템에 전파
    - 주문 데이터 상태가 변경됐을 때, 통지 시스템에는 주문ID와 변경된 상태만 필요하기에 데이터를 가공해서 보낸다.
- 목적에 따라 CDC 처리기는 DB, 메시징 시스템, API 등 다양한 대상에 데이터를 전파할 수 있다.
- CDC 처리기에서 로그 값을 기록하지 않으면 마지막 로그 데이터부터 읽어와야 하므로 재시작하는 동안 변경 데이터를 놓치게 된다.
- 시스템이 복잡해서 연동 코드를 넣기 부담스러울 때 CDC를 유용하게 활용할 수 있다. (신주문 시스템의 코드를 수정하지 않고 CDC를 사용해서 변경 데이터를 관련 시스템에 전파)

### ETC.

여러 메시징 시스템의 특징

1. Kafka
    - 높은 처리량
    - 메시지를 파일에 로그 형태로 저장 (재처리 가능)
    - 소비자가 브로커에서 메시지를 읽음 (pull)
2. RabbitMQ
    - 메시지 전달의 안정성 및 복잡한 라우팅
    - 메시지를 큐에 저장 후 소비되면 삭제 (재처리 불가)
    - 브로커가 소비자에게 메시지를 전송 (push)
3. Redis pub/sub
    - 빠른 인메모리 캐시와 간단한 실시간 통신
    - 메시지를 저장하지 않음 (재처리 불가)
    - 브로커가 소비자에게 메시지를 전송 (push)

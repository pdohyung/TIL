# 02. 인덱스 기본

데이터를 찾는 방법은 2가지

1. 테이블 전체를 스캔한다.
2. 인덱스를 이용한다.

인덱스 스캔 효율화 튜닝

- 시력 1.0 ~ 1.5인 홍길동 학생을 찾는 경우는 이름, 시력순으로 정렬하면 소량 스캔이 가능하다.

테이블 랜덤 엑세스 최소화 튜닝

- 이름순, 시력순으로 정렬된 테이블이 따로 존재하고 시력이 1.0 ~ 1.5인 학생이 50명, 이름이 홍길동인 학생이 5명이라면 5번만 엑세스하는 이름 인덱스가 효율적이다.

인덱스 구조

- 뿌리, 브랜치, 리프로 구성된다.
- 루트와 브랜치는 하위 블록에 대한 주소값을 가진다. 그리고 가장 왼쪽 레코드는 키값을 갖지 않는다. LMC라고 하는데 LMC를 따라가면 키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다.
- 리프 블록의 레코드는 키값 순으로 정렬돼 있고, 테이블 레코드를 가리키는 값인 ROWID를 가진다.
    - ROWID = 데이터 블록 주소 + 로우 번호

인덱스 탐색 과정

- 수직적 탐색: 루트부터 리프까지 조건을 만족하는 첫 번째 레코드(인덱스 스캔 시작지점)를 찾는다.
- 수평적 탐색: 수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 안 나타날 때까지 리프 블록을 수평적으로 스캔한다. (테이블 접근을 위한 ROWID 탐색)
    - 리프 블록끼리는 양방향 연결리스트 구조로, 앞뒤 블록에 대한 주소값을 가진다.

결합 인덱스 구조와 탐색

- 이름 + 성별이나 성별 + 이름처럼 2개 이상 컬럼을 결합해서 인덱스를 만들 수 있다. 어떻게 구성하든 읽는 인덱스 블록 개수는 똑같다.(블록 I/O 개수가 같음)
    - 남자 + 홍길동을 찾는 경우, 엑셀처럼 필드를 필터링하는 평면 구조가 아니고 다단계 구조라 어느 칼럼을 앞에 두든 일량에는 차이가 없다. (인덱스 구성에 따라 성능에 차이가 나는 것은 맞다.)
- Balanced의 의미: delete 작업으로 인해 인덱스 불균형 상태가 발생하지 않는다. 루트로부터 모든 리프 블록까지의 높이는 항상 동일하다.

인덱스 기본 사용법

- 인덱스 기본 사용법은 인덱스를 Range Scan 하는 방법을 의미한다. (인덱스 확장기능이 범위 탐색 이외의 스캔 방식)
- 인덱스 컬럼을 가공하면 스캔 시작점을 찾을 수 없기에 리프 전체를 탐색하는 Index Full Scan으로 동작한다.

인덱스를 Range Scan 할 수 없는 이유

- 인덱스 스캔 시작점을 찾을 수 없기 때문이다. 예를 들어 년도에 상관없이 5월에 태어난 사람을 찾는다면 풀스캔을 해야 할 것이다.
- OR, IN 조건식은 그대로 사용하면 시작점을 못찾지만, UNION ALL으로 변환하면 시작점을 찾을 수 있다.
    - OR Expansion과 IN-List Iterator

더 중요한 인덱스 사용 조건

- 인덱스 Range Scan을 하기 위한 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다. 예를 들어 소속팀 + 사원명 + 연령순으로 인덱스가 있을 때, 홍길동 이름의 사원은 소속팀이 다르면 멀어진다.
- 선두 컬럼이 가공되지 않은 상태로 조건절에 존재하면 인덱스를 타지만, 항상 성능이 좋은 건 아니다. 예를 들어, 주문일자 + 상품번호순으로 구성되고, 선두 컬럼인 주문일자가 조건절에 있으면서 상품번호만 가공할
  때, 스캔 범위를 줄이는 역할을 못한다면 인덱스를 잘 타는게 아니다.

인덱스를 이용한 소트 연산 생략

- 옵티마이저는 인덱스가 미리 정렬돼 있다면 ORDER BY의 정렬 연산을 따로 수행하지 않는다.
- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, 실행 계획에 SORT ORDER BY 연산 단계가 추가된다.

ORDER BY 절에서 컬럼 가공

- ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우가 있다. 예를 들어 장비번호 + 변경일자 + 변경순번순으로 구성됐을 때, ORDER BY
  변경일자 || 변경순번으로 가공하면 정렬 연산이 발생한다.
- 또 SELECT TO_CHAR(A.주문번호, ‘FM000000’) AS 주문번호 … ORDER BY 주문번호로 구성하면 가공된 값을 가리키기 때문에 정렬 연산이 발생한다. 이는 ORDER BY A.주문번호로
  수정하면 해결된다.

SELECT-LIST에서 컬럼 가공

- 장비번호 + 변경일자 + 변경순번순으로 구성하면, 아래의 값을 구할 때 정렬 연산을 수행하지 않는다. 실행 계획에는 인덱스 리프 블록의 왼쪽(MIN) 또는 오른쪽(MAX)에서 레코드 하나(FIRST ROW)만
  읽고 멈춘다.
    - SELECT MIN(변경순번) … WHERE 장비번호 = ‘C’ AND 변경일자 = ‘20180316’
    - SELECT MAX(변경순번) … WHERE 장비번호 = ‘C’ AND 변경일자 = ‘20180316’
- SELECT NVL(MAX(TO_NUMBER(변경순번)), 0) … 해당 SQL은 숫자값으로 바꾼 값 기준으로 요구했기 때문에 정렬 연산이 발생한다. 해결하려면 TO_NUMBER(MAX(변경순번))으로 바꾸면
  된다. (변경순번이 고정너비로 입력돼 있어야 함, 000001, 131517 …)
- 또 다른 예제로 최종 변경일자와 최종 변경순번 출력한다고 해보자. 스칼라 서브쿼리를 이용해 조회할 수 있다. 하지만 테이블을 여러 번 읽어야 하므로 비효율적이다. PK 컬럼이 더 많아지면 SQL 문도 훨씬 더
  복잡해지므로 성능도 나빠진다.

```code
SELECT 장비번호, 장비명, 상태코드
	, SUBSTR(최종이력, 1, 8) 최종변경일자
	, SUBSTR(최종이력, 9) 최종변경순번
FROM (
	SELECT 장비번호, 장비명, 상태코드
	, (SELECT MAX(변경일자 || 변경순번)
		 FROM 상태변경이력
		 WHERE 장비번호 = P.장비번호) 최종이력
	FROM 장비 P
	WHERE 장비구분코드 = 'A001'
)
```

- 해당 쿼리는 이력이 많지 않으면 상관없지만, 이력이 많으면 인덱스 컬럼을 가공했기 때문에 성능에 문제가 될 수 있다. 각 장비에 속한 과거 이력 데이터를 모두 읽어야 하므로 장비당 이력 레코드가 많다면 성능이 안
  좋아진다. 이에 대한 해법은 5장 이력 조회에서 살펴본다.

자동 형변환

- 컬럼이 문자형인데 조건절 비교값이 숫자형이면 오라클은 자동으로 형변환 처리를 한다. 숫자형과 문자형이 만나면 숫자형이 이긴다. 날짜형과 문자형이 만나면 날짜형이 이긴다. 좌변 컬럼을 기준으로 우변을 변환하면
  인덱스 사용에 문제는 없다. (날짜는 TO_DATE(...)로 날짜 포맷을 정확히 지정해 주는 것이 중요)
- 연산자가 LIKE일 때는 문자형 기준으로 숫자형 컬럼이 변환된다. 그리고 LIKE는 사용자가 입력하거나 입력하지 않거나 모두 처리할 수 있는 옵션 조건이 가능하다. (계좌번호 LIKE :
  acnt_no || ‘%’, NULL 값을 입력하면 전체 조회) 하지만 계좌번호 컬럼이 숫자형일 때 주의가 필요하다. 계좌번호 + 거래일자순으로 구성된 인덱스라면 Range Scan을 할 수 없다.
- 애플리케이션 품질 측면에서 자동 형변환을 주의해야 한다. 예를 들어 숫자형 컬럼(n_col)과 문자형 컬럼(v_col)을 비교하면 문자형 컬럼이 숫자형으로 변환되는데, 변환할 수 없는 문자가 입력되면 에러가
  발생한다.
- 결과 오류가 생기는 사례도 있다. decode(a, b, c, d)를 처리할 때 a=b면 c를 반환하고 아니면 d를 반환한다. 이때 값의 데이터 타입은 c에 의해 결정되는데, c가 문자형이고 d가 숫자형이면 d가
  변환된다. 그리고 c가 null로 입력되면 varchar2로 취급된다. 그래서 반환값을 숫자형으로 취급하고 싶으면 c 인자에 to_number(null)이나 0을 써야 한다.
- 형변환 함수를 생략한다고 성능이 크게 좋아지지는 않기에 블록 I/O를 줄이는 방법을 고민하자.

인덱스 확장기능 사용법

Index Range Scan

- 인덱스 루트에서 리프 블록까지 수직적으로 탐색한 후에 필요한 범위만 스캔한다.
- 선두 컬럼을 가공하지 않은 상태로 조건절에 사용해야 한다.
- 무조건 성능이 좋은 것은 아니고, 인덱스 스캔 범위와 테이블 엑세스 횟수로 결정된다.

Index Full Scan

- 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평 탐색한다.
- 최적의 인덱스가 없을 때 차선으로 선택된다. (인덱스 선두 컬럼이 조건절에 없는 경우 + 테이블이 커서 용령이 큰 경우)
- 극히 일부라면 Table Full Scan보다 효율적이지만 결과 레코드가 많아질수록 테이블 엑세스가 많아져서 비효율적이다.
- 옵티마이저에 first_rows 힌트를 주면, 인덱스를 선택하기에 결과 데이터가 많은 경우 주의해야 한다.

Index Unique Scan

- 수직적 탐색만으로 데이터를 찾는 스캔 방식으로 Unique 인덱스를 = 조건으로 탐색하는 경우만 작동한다.
- Unique 인덱스도 범위검색 조건으로 검색할 때는 Index Range Scan이 나타난다.

Index Skip Scan

- 오라클에서는 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 Index Skip Scan이 존재한다.
- 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용하다.
- 성별 = ‘남’이면서 연봉 ≥ 2000인 레코드를 찾을 때, 적합한 레코드를 찾으면 차례대로 스캔하다가 다른 레코드를 만나면 스캔을 멈춘다.
- 인덱스 선두 컬럼을 뺀 경우, index_ss, no_index_ss 힌트를 사용하고, 루트 또는 브랜치 블록에서 읽은 칼럼 값 정보를 이용해 ‘가능성이 있는’ 리프 블록만 액세스하는 스캔 방식이다.
- 선두 컬럼에 대한 조건절이 있고, 중간 컬럼에 대한 조건절이 없는 경우도 Skip Scan이 가능하다.
    - 후행 컬럼만 있을 때도 가능하다.
    - 선두 컬럼이 범위검색 조건일 때도 가능하다.
- 이처럼 Index Range Scan이 불가능하거나 효율적이지 못한 상황에서 Index Skip Scan이 종종 빛을 발한다. 부분범위 처리가 가능하다면 Index Full Scan이 도움이 되기도 한다.
- **하지만 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 하며, 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때 차선책으로 활용할 수 있는 전략이다.**

Index Fast Full Scan

- Index Fast Full Scan은 논리적인 인덱스 트리를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문에 빠르다. (관련 힌트는 index_ffs와
  no_index_ffs)
- Multiblock I/O 방식을 사용하므로 대량의 인덱스 블록을 읽어야 할 때 좋다. (병렬 쿼리 시 Direct Path I/O 방식이라 속도가 더 빠름)
- 하지만 리프 노드가 갖는 구조를 무시하고 읽기 때문에 인덱스 키 순서대로 정렬되지 않는다.
- 쿼리에 사용한 컬럼이 모두 인덱스에 포함될 때만 사용할 수 있다.
- Index Range Scan, Index Full Scan과 달리 인덱스가 파티션 돼 있지 않아도 병렬 쿼리가 가능하다.

Index Range Scan Descending

- Index Range Scan과 기본적으로 동일한 스캔 방식이고, 뒤에서부터 스캔하기 때문에 내림차순으로 정렬된다.
- 만약 옵티마이저가 인덱스를 거꾸로 읽지 않는다면, index_desc 힌트를 이용해 유도할 수 있다.

## 동시성 제어와 MVCC

동시성 제어란 다중 트랜잭션의 상호간섭 작용에서 DB를 보호하는 것을 의미한다. 일반적으로 동시성이 허용되면 일관성이 낮아진다. 동시성을 제어하는 방법에는 낙관적 동시성 제어와 비관적 동시성 제어가 있다.

낙관적 동시성 제어

- 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정
- 데이터를 읽는 시점에 Lock을 걸지 않는 대신 수정 시점에 값이 변경됐는지를 반드시 검사

비관적 동시성 제어

- 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
- 데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료될 때까지 이를 유지
- SELECT 시점에 Lock을 거는 비관적 락은 시스템의 동시성을 심각하게 저하해서 wait 또는 nowait 옵션과 함께 사용

동시성 제어의 목표는 동시에 실행되는 트랜잭션 수를 최대화하면서 CRUD 데이터의 무결성을 유지하는 데 있다. 따라서 동시 업데이트가 거의 없는 경우라면 낙관적 락을 사용하면 되지만, 아니라면 비관적 락을 사용해야
한다.

### 공유락(Shared Lock)과 배타락(Exclusive Lock)

비관적 동시성 제어를 위한 대표적인 방법으로 2가지가 있다.

- 공유락: 읽기 잠금
- 배타락: 쓰기 잠금

동일한 레코드에 대해 각각 공유락과 배타락을 가져간 경우, 동작은 다음과 같다.

- 1번 트랜잭션 공유락을 가져간 경우
    - 2번 트랜잭션이 데이터를 읽는 경우는 데이터가 일관되므로, 또 다른 공유락을 가져가며 동시에 처리함
    - 2번 트랜잭션이 데이터를 쓰는 경우는 1번 트랜잭션과 데이터가 달라질 수 있으므로, 1번 트랜잭션 종료까지 기다림.
- 1번 트랜잭션이 배타락을 가져간 경우
    - 2번 트랜잭션이 데이터를 읽는 경우는 1번 트랜잭션이 데이터를 변경할 수 있으므로 기다림.
    - 2번 트랜잭션이 데이터를 쓰는 경우도 1번 트랜잭션이 데이터를 변경할 수 있으므로 기다림.

### Locking 매커니즘의 문제점

락을 해제하는 방법은 커밋과 롤백밖에 없다. 이러한 일반적인 Locking 매커니즘은 간단하지만 아래와 같은 문제점을 가진다.

- 읽기 작업과 쓰기 작업이 서로 방해를 일으키기 때문에 동시성 문제가 발생(성능, 데드락, UX)
- 데이터 일관성에 문제가 생기는 경우도 있어서 락을 더 오래 유지하거나 테이블 레벨의 락을 사용해야 하고, 동시성 저하가 발생

### MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)

MVCC는 동시 접근을 허용하는 DB에서 동시성을 제어하기 위해 사용하는 방법 중 하나다.

원본의 데이터와 변경 중인 데이터를 동시에 유지하는 방식으로 원본 데이터에 대한 snapshot을 백업하여 보관한다. 만약 2가지 버전의 데이터가 동시에 존재하면 사용자는 snapshot을 읽는다.

- 변경이 취소되면 원본 snapshot을 바탕으로 데이터 복구
- 변경이 완료되면 최종적으로 디스크에 반영

이렇게 하나의 데이터에 대해 여러 버전의 데이터가 존재하게 되고, 사용자는 마지막 버전의 데이터를 읽는다. MVCC의 특징은 다음과 같다.

- 일반적인 RDBMS보다 매우 빠르게 작동
- 사용하지 않는 데이터가 계속 쌓이게 되므로 데이터를 정리하는 시스템이 필요
- 데이터 버전이 충돌하면 애플리케이션 영역에서 이러한 문제를 해결해야 함

MVCC는 **잠금이 필요 없기 때문에** 일반적인 RDBMS보다 빠르게 동작한다. 또한 데이터를 읽기 시작할 때, 다른 사람이 데이터를 수정하거나 삭제해도 영향받지 않는다. 대신 **사용하지 않는 데이터가 계속
쌓이므로 데이터를 정리**해야 한다. 그리고 여러 버전의 **데이터가 충돌할 수 있으므로 애플리케이션 영역에서 이러한 문제를 해결**해야 한다. UNDO 블록 I/O, CR Copy 생성, CR 블록 캐싱 같은 부가
작업의 오버헤드 발생한다. MVCC는 문장 수준과 트랜잭션 수준의 읽기 일관성이 존재한다.

- MySQL의 InnoDB에서는 Undo Log를 활용해 MVCC 기능을 구현한다.
- 일반적으로 조회하면 메모리와 디스크의 데이터가 동일하므로 같은 값을 조회한다.
- update문이 실행되면 commit 여부가 무관하게 InnoDB 버퍼 풀은 새로운 값으로 갱신된다. 그리고 undo log에는 변경 전의 값들만 복사된다. 버퍼 풀의 내용은 백그라운드 스레드를 통해 디스크에
  기록되는데, 반영되었는지는 시점에 따라 다를 수 있다.
- commit이나 rollback이 호출되지 않은 상태에서 다른 사용자가 조회하면, 트랜잭션 격리 수준에 따라 반환되는 데이터가 달라진다.
- rollback을 하면 버퍼 풀은 이전값으로 복구하고 undo log를 정리한다. commit은 변경된 값이 유지되면서 undo log도 다른 사람이 조회할 수 있으므로 삭제하지 않는다.

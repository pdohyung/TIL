# 스프링 빈

- 스프링 IoC 컨테이너(Application Context)가 관리하는 객체
- 빈 객체를 사용하지 않는다면, new 연산자를 통해 객체를 생성해서 주입해야 한다.
    - 만약 주입 객체가 수정된다면, 수정 범위가 넓다.
    - 의존성 관계가 복잡하다면, 동일 객체를 여러 번 생성할 수도 있다. (GC의 오버헤드)
- 위 문제를 보완하기 위해, 주입에 쓰이는 객체를 빈으로 등록하여 IoC 컨테이너가 관리한다.
    - 이를 통해 개발자는 주입된 의존성을 사용하는 부분에만 집중할 수 있다.

## 싱글톤

- 스프링 빈은 싱글톤인데, 직접 구현한 싱글톤 객체를 사용한다면 ?
    - 객체의 생성자가 private이라서 상속이 안되기 때문에 '다형성'을 적용하지 못한다.
    - 테스트 순서에 따라 단위 테스트 결과가 달라질 수 있다. (공유 객체 문제)
- 컨테이너는 싱글톤 패턴을 보완한 상태로 빈을 관리한다.
    - @Bean, @Component, @Service 등을 통해 컨테이너가 직접 객체를 생성하고, 매번 동일한 객체를 반환한다. (싱글톤 레지스트리, Map 형태)
    - @Bean은 @Configuration의 CGLIB 바이트 코드 조작을 통해 싱글톤을 보장한다.
    - 공유 객체인 것은 여전하기에 상태를 저장하는 코드는 작성하면 안된다. (stateless)

## 빈 생명주기

- 빈은 어노테이션 메타데이터(`@Component`, `@Service` 등) 정보를 읽고, POJO 형식의 클래스를 빈으로 등록한다.
    - 메타데이터는 `@Component` = 스프링 빈 등록, `@Configuration` = 설정 클래스, `@Transactional` = 트랜잭션 경계 지정 등의 예시가 있다.
    - POJO 형식이 아니고, 외부 프레임워크에 의존한다면(무거운 객체가 된다면) DI, 변경, 테스트가 어렵다.

> **빈의 라이프 사이클**  
> 컨테이너 생성 → 빈 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸 전 콜백 → 스프링 종료

- 빈은 초기화 시점과 소멸 직전에 콜백을 통해 시작, 종료 작업을 수행할 수 있다.
- 일단 핵심은 객체 생성과 초기화가 분리된다.
    - 생성자는 필수 파라미터를 받고, 메모리를 할당해서 객체를 생성하는 책임
    - 반면 초기화는 생성된 객체를 활용해서 외부 커넥션(DB, 외부 API 등)과 연결하는 무거운 동작 수행
    - 이렇게 명확하게 나누는 것이 유지보수 관점에서 좋지만, 초기화 작업이 단순하다면 생성자에서 처리하는 것이 낫다.
- `@PostConstruct`, `@PreDestroy`로 초기화 시점, 소멸 직전에 수행할 메서드를 설정할 수 있다.

## 빈 스코프

- 스코프는 빈이 존재할 수 있는 범위다. 기본적으로 싱글톤 스코프를 사용한다.
- 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프다.
- 프로토타입: 스프링 컨테이너가 생성, 의존관계 주입, 초기화까지만 관여하고 더는 관리하지 않는다.
    - 클라이언트 요청마다 새로운 프로토타입 빈을 생성해서 반환
    - 클라이언트가 빈을 관리할 책임을 가짐
    - `@PreDestroy`가 호출되지 않음

## 2장 느려진 서비스 어디부터 봐야 할까

### 처리량과 응답시간

- 응답시간: 사용자의 요청을 처리하는 데 걸리는 시간이다. API 요청시간-서버의 처리시간-API 응답시간으로 구성
- 서버 처리 시간: [로직 수행, DB 연동, 외부 API 연동, 응답 데이터 생성]으로 구성되는데 DB I/O와 API 연동이 가장 큰 비중을 차지한다.

이러한 이유로 응답시간을 줄일 때는 DB, API 연동 시간에 집중한다.

- 처리량: 단위 시간당 시스템이 처리하는 작업량을 의미한다. TPS나 RPS로 나타낸다. 혼용해서 사용하기도 한다.
    - TPS: 초당 트랜잭션 수
    - RPS: 초당 요청 수

동시에 들어오는 요청 수가 최대 TPS를 초과하면 서버는 초과된 요청을 나중에 처리하는데 응답 시간이 길어지면 사용자 이탈로 이어질 수 있다. 이러한 성능을 개선하려면 현재 서버의 TPS와 응답 시간을 알아야 한다.

1. 트래픽이 많은 시간대의 TPS와 응답 시간 측정 (스카우터, 엘라스틱서치, 핀포인트)
2. 결과를 바탕으로 목표 TPS와 응답 시간을 설정하고 효과적인 성능 개선안을 도출
    - 서버가 동시에 처리할 수 있는 요청 수를 늘려 대기 시간 줄이기
    - 처리 시간 자체를 줄여 대기 시간 줄이기

### 병목 지점과 확장

**서버 관점**에서 처리량과 응답 시간을 개선하는 방법은 다음과 같다.

- 수직 확장(scale-up): CPU, 메모리, 디스크 등의 자원을 증가 시킨다. 완전히 중단되는 것보단 느리더라도 서비스를 제공할 수 있다.
- 수평 확장(scale-out):  서버를 추가해 TPS를 높인다. 수직 확장은 비용이 많이 들기에 한계가 있다. 또한 DB나 외부 API의 성능이 문제인 경우는 더 악화될 수 있기에 효과가 없다.
    - 로드밸런서: 서버가 두 대 이상이면 사용자 트래픽을 골고루 분배하기 위해 필요하다. 크게 두 가지 방식으로 나뉜다.
    - 정적인 방식: 라운드 로빈, IP 해시 방식
    - 동적인 방식: 동적으로 트래픽 분산 (연결 수가 더 적은 서버, 응답 시간이 더 짧은 서버)

### DB 커넥션 풀

서버와 DB는 네트워크 통신으로 연결되기 때문에 쿼리 실행 시간에 비해 긴 시간이 걸린다. 매 요청마다 DB를 연결하고 종료하면 트래픽이 증가할 때 급격하게 처리량이 떨어지므로 **DB 커넥션 풀**을 사용한다.

- DB 커넥션 풀은 DB 커넥션을 미리 생성해서 보관하고, 필요할 때 가져와 사용하며, 작업이 끝나면 다시 풀에 반환한다. 이미 연결된 커넥션을 재사용하기 때문에 응답 시간이 줄어드는 장점이 있다.
- 커넥션 풀은 다양한 설정을 제공하는데, 그중 중요한 설정은 다음과 같다.
    - 커넥션 풀 크기 (최소 크기, 최대 크기)
        - 커넥션을 얻기 위해 대기하는 시간을 줄이려면 **응답 시간**과 **TPS**를 고려하여 커넥션 풀 크기를 지정해야 한다. (커넥션 풀 크기 5,쿼리 실행 0.1초일 때는 괜찮지만 쿼리 실행 시간이
          0.5초라면 풀 크기를 25으로 설정)
        - 트래픽이 급증하는 패턴을 보인다면 커넥션 풀의 **최소 크기를 최대 크기에 맞추는 것이 좋다.** (수평 확장과 마찬가지로 무턱대고 늘리면 DB의 부하가 커질 수 있으므로 주의)
    - 풀에 커넥션이 없을 때 커넥션을 구할 때까지 대기 시간
        - 대기 시간이 길고 재요청이 반복된다면 동시에 처리해야 할 요청 수는 계속 증가한다. (10개의 쿼리가 실행 중, 20개가 대기 중인데 10개가 취소하고 재요청한다면 대기 중인 요청 수는 총 30개)
        - 요청 수가 증가하면 그만큼 서버에 가해지는 부하도 커지기 때문에 **대기 시간을 0.5초에서 3초 이내로 지정하는 것이 좋다.** (사용자에게 ‘일시적 오류’와 같은 응답을 보낼 수 있음)
    - 커넥션의 유지 시간
        - MySQL과 같은 DB는 일정 시간 동안 상호작용이 없으면 DB와의 연결이 끊어질 수 있다. 끊어진 커넥션을 사용하면 에러가 발생하는데, 이를 방지하기 위해 다음 기능을 제공한다.
        - 최대 유휴 시간 지정: 유휴 시간을 30분으로 설정하면 30분이 지나면 **커넥션은 종료되어 풀에서 제거된다.** (비활성 유지 시간보다 짧게 설정하면, DB가 연결을 끊기 전에 풀에서 제거할 수
          있다.)
        - 유효성 검사: 커넥션이 정상적으로 사용할 수 있는 상태인지 여부를 확인한다. **연결이 유효하지 않은 커넥션을 식별하고 풀에서 제거한다.** (SELECT 1 FROM dual / SELECT 1
          으로 확인)
        - 최대 유지 시간: 4시간으로 설정했다면, 4시간이 지나고 **커넥션이 유효하더라도 풀에서 제거된다.**

### 서버 캐시

DB 서버를 확장하지 않고도, 캐시를 통해 응답시간과 처리량을 개선할 수 있다.

- 일반적으로 데이터를 읽는 속도가 DB보다 빠르기 때문에 자주 조회되는 데이터를 보관하면 응답 시간을 줄일 수 있다.
- 캐시의 동작 방식은 먼저 캐시를 조회-값이 존재하면 사용-없으면 DB 쿼리를 통해 조회한 후, 해당 값을 캐시에 저장하고 사용한다.
- 캐시는 (키:값) 형태로 데이터를 저장하므로 적절한 키가 필요하다. (게시글 정보 = articles:번호, 인기 글 = articles:hot10)

캐시가 얼마나 효율적으로 사용되는지는 적중률(hit rate)로 판단할 수 있다. (적중률 = 캐시에 존재한 건수 / 캐시에서 조회를 시도한 건수)

- 캐시에서 데이터를 100번 조회했는데 60번은 해당 데이터가 존재했다고 하면 캐시 적중률은 0.60, 60퍼가 된다.
- 모든 정보를 캐시에 저장하면 이론적으로 적중률이 100%지만 메모리 용량은 한계가 있기에 특정 대상을 삭제하고 새로운 데이터를 저장한다.
    - LRU(Least Recently Used): 가장 오래전에 사용된 데이터를 삭제
    - LFU(Least Frequently Used): 가장 적게 사용된 데이터를 삭제
    - FIFO(First In First Out): 먼저 추가된 데이터를 삭제

서버가 사용하는 캐시는 크게 두 종류가 있다. **로컬 캐시**는 서버 프로세스와 동일한 메모리를 캐시 저장소로 사용한다. **리모트 캐시**는 별도 프로세스를 캐시 저장소로 사용한다.

- **로컬 캐시**는 서버와 동일한 메모리 공간을 사용하므로 빠르다. 단점은 메모리 양에 한계가 있어 크기가 제한된다. 또한 프로세스를 재시작하면 캐시가 모두 삭제된다.


- **리모트 캐시**는 크기를 유연하게 확장할 수 있다. 그리고 재시작되더라도 저장된 캐시는 유지된다. 단점은 네트워크 통신을 해야 하기에 느리다.


- 캐시에 보관할 데이터가 작고 변경 빈도도 낮다면 **로컬 캐시**로 충분하다. 하지만 데이터 규모가 큰 쇼핑 사이트나 배포 빈도가 높은 서비스라면 **리모트 캐시**를 고려하는 것이 좋다.


- **캐시 사전 적재**: 트래픽이 순간적으로 급증하는 패턴을 보인다면 캐시에 데이터를 미리 저장하는 것이 좋다. 응답 시간 안정적으로 유지, DB 부하 방지 (모든 사용자들이 동시에 받은 요금 정보를 조회하는
  경우)


- **캐시 무효화**: 캐시를 사용할 때 원본이 바뀌면, 그에 맞춰 캐시에 저장된 데이터도 함께 변경되거나 삭제해야 한다. 사용자는 가격 정보, 게시글 내용처럼 민감한 데이터를 잘못된 정보로 접할 수 있다.


- **가비지 컬렉터**: GC는 사용이 끝난 객체를 힙 메모리에서 바로 삭제하지 않고 정해진 규칙에 따라 사용하지 않는 메모리를 찾아서 반환한다. GC가 실행되는 동안 프로그램이 일시 중단되는데, 이 시간을 최적화
  하기 위해 적절한 힙 메모리 크기를 고려해야 한다.
    - 한 번에 대량의 글을 조회하는 경우, 메모리 부족 사태가 발생할 수 있다. 조회 기간을 10년에서 3개월로 변경
    - 파일 다운로드는 스트림 활용 (파일을 8KB씩 끊어서 읽으면 100명인 경우 메모리 800KB 필요)


- **응답 데이터 압축**: 서버는 사용자의 네트워크 속도를 제어할 수 없지만 전송하는 데이터 크기는 제어할 수 있다. 이때 사용하는 방법이 응답 데이터를 압축해서 전송하는 것이다. (HTML, CSS, JS,
  JSON)
    - 비용 절감 효과, 아파치나 Nginx와 같은 웹 서버도 압축 기능을 제공한다.


- **브라우저 캐시**: 서버는 2가지 종류의 데이터를 응답한다. 동적자원 (요청마다 바뀌는 데이터 = JSON)과 정적 자원(요청마다 같은 데이터)이다. 정적 자원이 많은 비중을 차지하기에
  Cache-Control이나 Expires 헤더로 클라이언트 캐시를 이용하면 트래픽 비용을 줄일 수 있다.


- **CDN**: 브라우저 캐시는 브라우저 단위로 동작하기 때문에 동시에 많은 사용자가 접속하면 순간적으로 응답이 느려진다. 이를 해결하기 위해 CDN(콘텐츠를 제공하기 위한 별도의 네트워크)를 사용한다.
    - 사용자는 CDN URL 접근-CDN 서버에 콘텐츠가 없으면 오리진 서버 접근-읽어온 콘텐츠를 캐시에 보관한다. 이를 통해 오리진 서버가 처리해야 할 트래픽을 상당히 줄일 수 있다.


- **대기 처리**: 콘서트 예매와 같이 트래픽이 폭증하는 경우 서버, DB 증설을 통해 해결할 수 있지만 비용이 커서 문제가 된다. 특히 DB는 성능을 높이면 줄이기가 쉽지 않다. **반대의 접근으로 시스템의
  처리량을 늘리기보다 수용할 수 있는 트래픽만 받고 나머지는 대기 처리한다.**

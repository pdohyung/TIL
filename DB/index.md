## 인덱스란 ?

사전적 정의는 색인으로 쉽게 찾아볼 수 있도록 일정한 순서에 따라 놓은 목록이다.  
색인을 통해 원하는 값을 빠르게 찾는 것이 목적이다.  
데이터베이스에서는 조회 쿼리(SELECT)에 적용할 수 있다.

이름, 성별, 이메일 등으로 이루어진 테이블에 대해서 특정 이메일로 조회를 해보자.

- 인덱스 기준이 잡혀 있지 않다면, 전체 데이터를 순차적으로 확인해서 느릴 것이다.
- 하지만 인덱스를 이메일로 설정하면, 이메일을 기준으로 데이터가 정렬되고 조회하면 속도는 빨라진다.

이처럼 데이터가 특정 기준으로 정렬돼 있다면 검색을 빠르게 할 수 있다.

```sql
# WHERE 절을 사용해서 인덱스를 적용
SELECT *
FROM member
WHERE email = 'pdohyung@gmail.com';

# WHERE 절을 사용하지 않아서 인덱스가 적용되지 않음
SELECT *
FROM member;
```

인덱스는 데이터베이스에 대한 검색 성능이 향상되는 자료구조이며, WHERE 절 등을 통해 활용된다.  
데이터베이스 인덱스의 특징은 다음과 같다.

- 인덱스는 항상 최신의 정렬 상태를 유지
- 인덱스도 하나의 데이터베이스 객체
- 데이터베이스 크기의 약 10% 정도의 저장공간 필요

## 인덱스 알고리즘

> **페이지:** 데이터가 저장되는 단위 (MySQL = 16KB)

### Full Table Scan

- 데이터를 순차적으로 접근
- 접근 비용 감소
- Full Table Scan이 사용되는 경우 (인덱스가 적용돼도 성능상 이점이 없는 경우)
    - 인덱스를 적용할 대상이 없는 경우
    - 인덱스 처리 범위가 넓은 경우
    - 크기가 작은 테이블에 접근하는 경우

> **Binary Search Tree (이진 탐색 트리)**  
> 이진탐색과 연결리스트의 장점을 합쳐서 만든 자료구조
> - 균형 있는 BST의 시간복잡도: O(logN)
> - 균형 없는 BST의 시간복잡도: O(N)

균형 없는 BST의 단점을 보완하고자 나온 것이 B-Tree다.

### B-Tree

- 트리 높이가 같음
- 자식 노드를 2개 이상 가질 수 있음
- 기본 데이터베이스 인덱스 구조
- 구조
    - **루트 페이지:** 자식 페이지의 정보, 최상단에 위치
    - **브랜치 페이지:** 자식 페이지의 정보, 루트와 리프 사이에 위치
    - **리프 페이지:** 실제 데이터 페이지 (클러스터링 인덱스), 실제 데이터의 주소 페이지 (논-클러스터링 인덱스)

### 성능

- **SELECT:** B-Tree 덕분에 조회 성능은 향상된다.
- **INSERT:** 특정 페이지 내부에서 작업한다면 큰 부담이 없지만, 페이지가 꽉 찬다면 비어있는 페이지를 확보하고 문제가 있는 페이지의 데이터를 공평하게 나누기 때문에 부담이 된다. (페이지 분할)

> **페이지 분할**
> - 페이지에 새로운 데이터를 추가할 여유 공간이 없어 페이지에 변화가 발생
> - DB가 느려지고 성능에 영향을 준다.

- **DELETE:** 인덱스의 데이터를 실제로 지우지 않고 사용안함을 표시한다.
- **UPDATE:** 인덱스에 UPDATE 기능은 없고, 기존 값을 DELETE(사용안함 표시)하고 INSERT 한다.

> **그러면 UPDATE, DELETE도 WHERE 절을 사용할 때, 빨라지지 않나 ?**  
> 처리할 대상을 찾는 조회 성능은 향상된다.
> - 사용하지 않는 인덱스가 적용됐다면 불필요한 처리량 증가
> - 사용안함 표시로 페이지 낭비 및 인덱스 조각화 심해짐

최종적으로 SELECT는 성능이 향상되지만, INSERT, UPDATE, DELETE는 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다.

## 인덱스 종류

클러스터란 무리, 무리를 이루다 라는 뜻이다.  
데이터베이스에서 **클러스터링 인덱스**란 실제 데이터와 같은 무리의 인덱스다. 실제 데이터가 정렬된 사전 역할을 한다.  
**논-클러스터링 인덱스**란 실제 데이터와 다른 무리의 별도의 인덱스다. 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 역할을 한다.

```sql
CREATE TABLE member
(
    id    int,         # primary key, 클러스터링 인덱스
    name  varchar(255),
    email varchar(255) # unique, 논-클러스터링 인덱스
);
```

### 클러스터링 인덱스

클러스터링 인덱스를 적용해 보자. (id 칼럼에 적용)

1. 인덱스가 없는 회원 테이블을 생성한다.
2. 데이터를 넣으면 삽입 순서대로 저장된다.
3. id 칼럼에 클러스터링 인덱스를 적용한다.
    - primary key
    - unique + not null
4. 클러스터링 인덱스를 적용한 id 칼럼을 기준으로 데이터 정렬되고 리프 페이지(데이터 페이지)가 된다.
5. 정렬된 데이터를 기준으로 페이지 주소를 가진 루트 페이지가 생성된다. (B-Tree 구조)

여기서 리프 페이지는 데이터 페이지(실제 데이터가 저장된 곳)다.  
클러스터링 인덱스의 특징은 아래와 같다.

- 실제 데이터 자체가 정렬
- 테이블당 1개만 존재 가능
- 리프 페이지가 데이터 페이지
- primary key나 unique + not null 제약조건 시 자동 생성

### 논-클러스터링 인덱스

논-클러스터링 인덱스를 적용해 보자. (name 칼럼에 적용)

1. 인덱스가 없는 회원 테이블을 생성한다.
2. 데이터를 넣으면 삽입 순서대로 저장된다.
3. name 칼럼에 논-클러스터링 인덱스를 적용한다.
    - unique 제약조건을 건다.
    - unique index를 생성한다. (중복 허용 X)
    - index를 생성한다. (중복 허용 O)
4. 실제 데이터 페이지는 변경되지 않고, 별도의 인덱스 페이지를 생성하여 리프 페이지로 사용한다.
    - 리프 페이지는 name 칼럼 순서로 정렬되고, 각 값은 데이터 페이지의 데이터 주소를 가진다.
5. 이 리프 페이지의 주소를 가진 루트 페이지가 생성된다.

클러스터링 인덱스와 다른 점은 리프 페이지가 데이터 페이지가 아닌 새롭게 생성된 인덱스 페이지다.  
아래는 논-클러스터링 인덱스의 특징이다.

- 실제 데이터 페이지는 그대로 존재
- 별도의 인덱스 페이지를 생성해서 추가 공간 필요
- 테이블당 여러 개의 논-클러스터링 인덱스가 존재 가능
- 리프 페이지는 실제 데이터 페이지 주소를 가짐
- unique 제약조건 적용 시 자동 생성
- 직접 index 생성 시 논-클러스터링 인덱스 생성

### 다수의 인덱스

만약 클러스터링 인덱스와 논-클러스터링 인덱스를 함께 적용하면 어떻게 될까 ?  
**id 칼럼에 클러스터링 인덱스 + name 칼럼에 논-클러스터링 인덱스**  
각각 적용할 때처럼 똑같을 것 같지만, 실제로는 인덱스 페이지가 데이터 페이지의 주소 값이 아닌 클러스터링 인덱스가 적용된 칼럼의 실제 값(id 칼럼 값)을 가진다.

이렇게 쓰는 이유는 기존처럼 사용하면 문제가 발생하기 때문이다.   
만약 페이지 분할로 인해 데이터 페이지가 변경된다면 주소 값도 바뀌게 되고, 연관 있는 인덱스 페이지는 모두 변경해야 한다.  
이렇게 데이터가 삽입, 삭제될 때마다 인덱스 페이지에 영향을 주기 때문에 클러스터링 인덱스 칼럼 값을 사용한다.

## 인덱스 적용 기준

### 카디널리티

카디널리티란 사전적 의미로 그룹 내 요소의 개수다.  
우리는 카디널리티가 높은 칼럼(= 중복 수치가 낮은 칼럼)에 인덱스를 적용해야 한다.

### 추가 적용 기준

1. **카디널리티가 높은 칼럼**
2. **WHERE, JOIN, ORDER BY 절에 자주 사용되는 칼럼** (조건절이 없다면 인덱스가 사용되지 않음)
3. **INSERT / UPDATE / DELETE 가 자주 발생하지 않는 칼럼**
4. **규모가 작지 않은 테이블**

### 인덱스 사용 시 주의 사항

1. **잘 활용되지 않는 인덱스는 과감히 제거하자.**
    - WHERE 절에 사용되더라도 자주 사용해야 가치가 있다.
    - 불필요한 인덱스로 성능 저하가 발생할 수 있다.
2. **데이터 중복도가 높은 칼럼은 인덱스 효과가 작다.**
3. **자주 사용되더라도 INSERT / UPDATE / DELETE 가 자주 일어나는지 고려해야 한다.**
    - 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기 비율은 2:8 또는 1:9이다.
    - 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법이다.
